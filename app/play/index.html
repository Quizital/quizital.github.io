<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QUIZITAL - Play</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/themium/FrameworkV0@main/v0.css">
<style>
body {
    font-family: Ubuntu, sans-serif;
    background: #1a1a2e;
    color: white;
    text-align: center;
    margin: 0;
    padding: 40px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    --scale: 1;
}

h1 { 
    font-size: calc(64px * var(--scale)); 
    margin-bottom: 30px; 
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.player-info {
    font-size: calc(24px * var(--scale));
    margin-bottom: 20px;
    padding: calc(15px * var(--scale));
    background: rgba(40, 49, 73, 0.8);
    border-radius: calc(12px * var(--scale));
    border-left: 5px solid #FFD700;
    min-height: calc(30px * var(--scale));
    display: flex;
    align-items: center;
    justify-content: center;
}

.question { 
    font-size: calc(32px * var(--scale)); 
    margin-bottom: 30px; 
    max-width: 1000px; 
    line-height: 1.4;
    padding: calc(20px * var(--scale));
    background: rgba(40, 49, 73, 0.3);
    border-radius: calc(15px * var(--scale));
}

.options { 
    display: flex; 
    flex-direction: column; 
    gap: calc(20px * var(--scale)); 
    max-width: 600px; 
    width: 90%; 
    margin: 0 auto; 
}

.option {
    background: #283149;
    padding: calc(24px * var(--scale)) calc(30px * var(--scale));
    border-radius: calc(12px * var(--scale));
    cursor: pointer;
    font-size: calc(28px * var(--scale));
    font-weight: bold;
    text-align: center;
    user-select: none;
    transition: all 0.3s ease;
    border: 2px solid transparent;
    position: relative;
    overflow: hidden;
}

.option:hover:not(.disabled) { 
    background: #3a3f58; 
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.option:focus {
    outline: 3px solid #FFD700;
    outline-offset: 2px;
}

.option.selected {
    border-color: #FFD700;
    background: #3a3f58;
}

.option.correct { 
    background: linear-gradient(45deg, #4CAF50, #66BB6A);
    animation: correctPulse 0.6s ease-in-out;
}

.option.wrong { 
    background: linear-gradient(45deg, #f44336, #ef5350);
    animation: wrongShake 0.6s ease-in-out;
}

.option.disabled {
    pointer-events: none;
    opacity: 0.7;
}

@keyframes correctPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes wrongShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.timer-container { 
    width: 100%; 
    max-width: 600px; 
    height: calc(25px * var(--scale)); 
    background: #333; 
    border-radius: calc(12px * var(--scale)); 
    overflow: hidden; 
    margin-bottom: 20px;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
}

.timer-bar { 
    height: 100%; 
    width: 100%; 
    background: linear-gradient(90deg, #4CAF50, #FFD700, #f44336); 
    transition: width 0.1s linear;
}

.score { 
    margin-top: 30px; 
    font-size: calc(32px * var(--scale)); 
}

.score h2 {
    color: #FFD700;
    margin-bottom: 20px;
}

.score ol {
    text-align: left;
    max-width: 400px;
    margin: 0 auto;
}

.score li {
    padding: calc(10px * var(--scale));
    margin: calc(5px * var(--scale)) 0;
    background: rgba(40, 49, 73, 0.5);
    border-radius: calc(8px * var(--scale));
    font-size: calc(24px * var(--scale));
}

.score li:first-child {
    background: linear-gradient(45deg, #FFD700, #FFA000);
    color: #1a1a2e;
    font-weight: bold;
}

.hidden { 
    display: none !important; 
}

.btn {
    display: inline-block;
    background: linear-gradient(45deg, #1c86cc, #2196F3);
    color: white;
    text-decoration: none;
    padding: calc(15px * var(--scale)) calc(35px * var(--scale));
    border-radius: calc(8px * var(--scale));
    font-size: calc(20px * var(--scale));
    font-weight: bold;
    transition: all 0.3s ease;
    margin-top: 20px;
    cursor: pointer;
    border: none;
    box-shadow: 0 4px 12px rgba(28, 134, 204, 0.3);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.btn:hover:not(:disabled) { 
    background: linear-gradient(45deg, #0064dc, #1976D2);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(28, 134, 204, 0.4);
}

.btn:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
    transform: none;
    box-shadow: none;
}

.btn:focus {
    outline: 3px solid #FFD700;
    outline-offset: 2px;
}

#settings-icon {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    background: linear-gradient(45deg, #283149, #3a3f58);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    cursor: pointer;
    user-select: none;
    z-index: 1000;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

#settings-icon:hover {
    transform: rotate(90deg) scale(1.1);
    background: linear-gradient(45deg, #3a3f58, #4a4f68);
}

#settings-icon:focus {
    outline: 3px solid #FFD700;
    outline-offset: 2px;
}

#settings-panel {
    position: fixed;
    bottom: 90px;
    right: 20px;
    background: linear-gradient(135deg, #222, #333);
    padding: 25px;
    border-radius: 15px;
    width: 320px;
    display: none;
    flex-direction: column;
    gap: 20px;
    z-index: 999;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    border: 1px solid #444;
}

#settings-panel label { 
    font-size: 16px; 
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
}

#settings-panel input[type="range"] { 
    width: 60%;
    margin-left: 10px;
}

#settings-panel input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-left: 10px;
}

.progress-container {
    margin-bottom: 20px;
    text-align: center;
}

.progress-bar {
    width: 100%;
    max-width: 600px;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 10px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #FFD700);
    transition: width 0.3s ease;
}

/* Large display mode */
.large-display {
    --scale: 1.5;
}

/* High contrast mode */
@media (prefers-contrast: high) {
    .option {
        border: 3px solid white;
    }
    
    .option:hover {
        background: white;
        color: black;
    }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus styles for keyboard navigation */
.option:focus,
.btn:focus,
#settings-icon:focus {
    outline: 3px solid #FFD700;
    outline-offset: 3px;
}

/* Screen reader only text */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}
</style>
</head>
<body>
<h1 class="tf_f-ubuntu tf_fw-200">QUIZITAL</h1>

<div class="progress-container hidden" id="progress-container">
    <div>Question <span id="current-question">1</span> of <span id="total-questions">0</span></div>
    <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
    </div>
</div>

<div class="player-info hidden" id="player-info" aria-live="polite"></div>

<div class="timer-container hidden">
    <div class="timer-bar" id="timer-bar"></div>
</div>

<div class="question" id="question-text" role="main" aria-live="polite" style="display: none;"></div>
<div class="options" id="options-container" role="group" aria-label="Answer options"></div>
<div class="score hidden" id="score-container" role="complementary"></div>
<button id="start-quiz-btn" class="btn" aria-describedby="quiz-instructions">Start Quiz</button>
<button id="next-btn" class="btn hidden" disabled>Next Question</button>
<button id="end-quiz-btn" class="btn hidden" style="background: linear-gradient(45deg, #f44336, #ef5350);">End Quiz</button>

<div id="quiz-instructions" class="sr-only">
    Press Enter or Space to select an answer option, or click with your mouse. Use Tab to navigate between options.
</div>

<!-- Settings -->
<div id="settings-icon" tabindex="0" role="button" aria-label="Open settings" aria-expanded="false">&#9881;</div>
<div id="settings-panel" role="dialog" aria-label="Settings">
    <label>
        Large Display Mode
        <input type="checkbox" id="large-display-toggle" aria-describedby="large-display-help">
    </label>
    <div id="large-display-help" class="sr-only">Increases the size of all text and elements for better visibility</div>
    
    <label>
        Volume: <span id="volume-value">100%</span>
        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1" aria-label="Volume control">
    </label>
    
    <label>
        Scale: <span id="scale-value">100%</span>
        <input type="range" id="scale-slider" min="0.5" max="2" step="0.01" value="1" aria-label="UI scale control">
    </label>
</div>

<script>
(async () => {
    const soundConfig = {
        correct: 'assets/audio/correct.mp3',
        wrong: 'assets/audio/wrong.mp3',
        tick: 'assets/audio/clock-tick-single.mp3'
    };

    const correctSound = new Audio(soundConfig.correct);
    const wrongSound = new Audio(soundConfig.wrong);
    const tickSound = new Audio(soundConfig.tick);
    let volume = 1;
    correctSound.volume = volume; 
    wrongSound.volume = volume; 
    tickSound.volume = volume;

    // Settings functionality
    const settingsIcon = document.getElementById('settings-icon');
    const settingsPanel = document.getElementById('settings-panel');
    const largeDisplayToggle = document.getElementById('large-display-toggle');
    const volumeSlider = document.getElementById('volume-slider');
    const volumeValue = document.getElementById('volume-value');
    const scaleSlider = document.getElementById('scale-slider');
    const scaleValue = document.getElementById('scale-value');

    settingsIcon.addEventListener('click', toggleSettings);
    settingsIcon.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleSettings();
        }
    });

    function toggleSettings() {
        const isVisible = settingsPanel.style.display === 'flex';
        settingsPanel.style.display = isVisible ? 'none' : 'flex';
        settingsIcon.setAttribute('aria-expanded', !isVisible);
    }

    largeDisplayToggle.addEventListener('change', () => {
        document.body.classList.toggle('large-display', largeDisplayToggle.checked);
    });

    volumeSlider.addEventListener('input', () => {
        volume = parseFloat(volumeSlider.value);
        volumeValue.textContent = Math.round(volume * 100) + '%';
        correctSound.volume = wrongSound.volume = tickSound.volume = volume;
    });

    scaleSlider.addEventListener('input', () => {
        document.body.style.setProperty('--scale', scaleSlider.value);
        scaleValue.textContent = Math.round(scaleSlider.value * 100) + '%';
    });

    // Quiz functionality
    const params = new URLSearchParams(window.location.search);
    const categoriesParam = params.get('categories');
    const multiplayerParam = params.get('multiplayer');
    const totalQuestionsParam = params.get('total');

    if (!categoriesParam) { 
        document.body.innerHTML = "<h1>No categories selected!</h1>"; 
        return; 
    }

    const categoryIds = categoriesParam.split(',');
    let questions = [];
    
    for (const id of categoryIds) {
        try { 
            const res = await fetch(`categories/${id}.json`); 
            if (!res.ok) continue; 
            questions = questions.concat(await res.json()); 
        } catch (e) { 
            console.error(`Failed to load category ${id}`, e); 
        }
    }

    if (questions.length === 0) { 
        document.body.innerHTML = "<h1>No questions found.</h1>"; 
        return; 
    }

    for (const q of questions) { 
        if (q.points === undefined) { 
            document.body.innerHTML = `<h1>Invalid JSON: Missing points for "${q.question}"</h1>`; 
            return; 
        } 
    }

    // Shuffle all questions together after loading from all categories
    questions = questions.sort(() => Math.random() - 0.5);
    
    // Apply total questions limit if specified
    let totalQuestionsToUse = questions.length;
    if (totalQuestionsParam) {
        const requestedTotal = parseInt(totalQuestionsParam);
        if (requestedTotal > 0 && requestedTotal <= questions.length) {
            totalQuestionsToUse = requestedTotal;
            questions = questions.slice(0, totalQuestionsToUse);
        }
    }

    let multiplayer = multiplayerParam ? multiplayerParam.split(',') : null;
    let scores = {};
    let currentPlayerIndex = 0;
    let currentQuestionIndex = 0; // Track which question we're on globally
    let playerAnswerCounts = {}; // Track how many questions each player has answered
    
    if (multiplayer) { 
        multiplayer.forEach(p => {
            scores[p] = 0;
            playerAnswerCounts[p] = 0;
        });
        
        if (totalQuestionsToUse < multiplayer.length) {
            document.body.innerHTML = `<h1>Not enough questions! Need at least ${multiplayer.length} questions for ${multiplayer.length} players.</h1>`;
            return;
        }
    } else { 
        scores = { Player: 0 };
        playerAnswerCounts = { Player: 0 };
    }
    let timerInterval = null;
    const questionEl = document.getElementById('question-text');
    const optionsEl = document.getElementById('options-container');
    const scoreEl = document.getElementById('score-container');
    const timerBarEl = document.getElementById('timer-bar');
    const timerContainer = document.querySelector('.timer-container');
    const startBtn = document.getElementById('start-quiz-btn');
    const nextBtn = document.getElementById('next-btn');
    const endBtn = document.getElementById('end-quiz-btn');
    const playerInfoEl = document.getElementById('player-info');
    const progressContainer = document.getElementById('progress-container');
    const currentQuestionEl = document.getElementById('current-question');
    const totalQuestionsEl = document.getElementById('total-questions');
    const progressFillEl = document.getElementById('progress-fill');

    let selectedAnswer = null;
    let currentPlayer = multiplayer ? multiplayer[currentPlayerIndex] : 'Player';
    let answerRevealed = false;

    totalQuestionsEl.textContent = totalQuestionsToUse;

    function updateProgress() {
        const progress = ((currentQuestionIndex + 1) / totalQuestionsToUse) * 100;
        
        if (multiplayer) {
            const currentPlayer = multiplayer[currentPlayerIndex];
            const playerQuestionNumber = playerAnswerCounts[currentPlayer] + 1;
            currentQuestionEl.textContent = `${currentPlayer} - Q${playerQuestionNumber}`;
        } else {
            currentQuestionEl.textContent = currentQuestionIndex + 1;
        }
        
        progressFillEl.style.width = `${progress}%`;
    }

    function updatePlayerInfo() {
        if (multiplayer) {
            const nextPlayerIndex = (currentPlayerIndex + 1) % multiplayer.length;
            const nextPlayer = multiplayer[nextPlayerIndex];
            const isLastQuestion = currentQuestionIndex === totalQuestionsToUse - 1;
            const currentPlayer = multiplayer[currentPlayerIndex];
            
            if (answerRevealed) {
                if (isLastQuestion) {
                    playerInfoEl.textContent = `Quiz Complete!`;
                    playerInfoEl.style.background = 'rgba(76, 175, 80, 0.2)';
                    playerInfoEl.style.borderLeftColor = '#4CAF50';
                } else {
                    playerInfoEl.textContent = `Next Up: ${nextPlayer}`;
                    playerInfoEl.style.background = 'rgba(255, 215, 0, 0.2)';
                    playerInfoEl.style.borderLeftColor = '#FFD700';
                }
            } else {
                const answeredQuestions = playerAnswerCounts[currentPlayer];
                playerInfoEl.textContent = `Current Player: ${currentPlayer} (answered ${answeredQuestions} questions)`;
                playerInfoEl.style.background = 'rgba(40, 49, 73, 0.8)';
                playerInfoEl.style.borderLeftColor = '#4CAF50';
            }
            playerInfoEl.classList.remove('hidden');
        } else {
            playerInfoEl.classList.add('hidden');
        }
    }

    function showQuestion() {
        clearInterval(timerInterval);
        answerRevealed = false;
        
        // Get current question based on global question index
        const q = questions[currentQuestionIndex];
        currentPlayer = multiplayer ? multiplayer[currentPlayerIndex] : 'Player';
        
        questionEl.style.display = ''
        questionEl.textContent = q.question;
        optionsEl.innerHTML = '';
        selectedAnswer = null;

        updateProgress();
        updatePlayerInfo();
        progressContainer.classList.remove('hidden');

        if (q.timeLimit && q.timeLimit > 0) {
            timerContainer.classList.remove('hidden');
            timerBarEl.style.width = '100%';
            let timeLeft = q.timeLimit;
            timerInterval = setInterval(() => {
                timeLeft -= 0.1;
                if (timeLeft <= 0) { 
                    clearInterval(timerInterval); 
                    if (!answerRevealed) {
                        revealAnswer();
                    }
                } 
                timerBarEl.style.width = `${(timeLeft / q.timeLimit) * 100}%`;
                if (volume > 0 && timeLeft % 1 < 0.1) {
                    tickSound.currentTime = 0; 
                    tickSound.play().catch(() => {});
                }
            }, 100);
        } else { 
            timerContainer.classList.add('hidden'); 
        }

        const opts = q.options.sort(() => Math.random() - 0.5);
        opts.forEach((opt, index) => {
            const btn = document.createElement('div');
            btn.className = 'option';
            btn.textContent = opt;
            btn.setAttribute('tabindex', '0');
            btn.setAttribute('role', 'button');
            btn.setAttribute('aria-label', `Option ${index + 1}: ${opt}`);
            
            btn.addEventListener('click', () => selectAnswer(opt, btn));
            btn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    selectAnswer(opt, btn);
                }
            });
            
            optionsEl.appendChild(btn);
        });

        nextBtn.classList.remove('hidden');
        endBtn.classList.remove('hidden');
        nextBtn.disabled = true;
        nextBtn.textContent = getNextButtonText();
    }

    function selectAnswer(answer, buttonEl) {
        if (answerRevealed) return;
        
        selectedAnswer = answer;
        
        // Remove previous selection
        Array.from(optionsEl.children).forEach(el => {
            el.classList.remove('selected');
        });
        
        buttonEl.classList.add('selected');
        buttonEl.focus();
        
        setTimeout(() => {
            revealAnswer();
        }, 500);
    }

    function getNextButtonText() {
        if (currentQuestionIndex >= totalQuestionsToUse - 1) {
            return 'Show Results';
        }
        
        if (multiplayer) {
            const nextPlayerIndex = (currentPlayerIndex + 1) % multiplayer.length;
            const nextPlayer = multiplayer[nextPlayerIndex];
            return `Next: ${nextPlayer}`;
        } else {
            return 'Next Question';
        }
    }

    function revealAnswer() {
        if (answerRevealed) return;
        answerRevealed = true;
        
        clearInterval(timerInterval);
        const q = questions[currentQuestionIndex];
        
        Array.from(optionsEl.children).forEach(el => {
            el.classList.add('disabled');
            if (el.textContent === q.answer) {
                el.classList.add('correct');
            } else if (el.textContent === selectedAnswer) {
                el.classList.add('wrong');
            }
        });

        if (selectedAnswer === q.answer) { 
            scores[currentPlayer] += q.points; 
            correctSound.play().catch(() => {}); 
        } else { 
            if (selectedAnswer !== null) wrongSound.play().catch(() => {}); 
        }

        // Increment the player's answer count
        playerAnswerCounts[currentPlayer]++;

        updatePlayerInfo();
        nextBtn.disabled = false;
        nextBtn.textContent = getNextButtonText();
        nextBtn.focus();
    }

    function nextQuestion() {
        // Move to next question
        currentQuestionIndex++;
        
        if (multiplayer) {
            // Move to next player
            currentPlayerIndex = (currentPlayerIndex + 1) % multiplayer.length;
        }
        
        // Check if we've reached the end
        if (currentQuestionIndex >= totalQuestionsToUse) {
            showScore();
        } else {
            showQuestion();
        }
    }

    function showScore() {
        // Hide all game elements
        questionEl.classList.add('hidden'); 
        optionsEl.classList.add('hidden'); 
        timerContainer.classList.add('hidden'); 
        nextBtn.classList.add('hidden'); 
        endBtn.classList.add('hidden');
        startBtn.classList.add('hidden');
        playerInfoEl.classList.add('hidden');
        progressContainer.classList.add('hidden');
        
        scoreEl.classList.remove('hidden');
        
        if (multiplayer) {
            let leaderboard = '<h2>🏆 Final Leaderboard</h2><ol>';
            Object.entries(scores).sort((a, b) => b[1] - a[1]).forEach(([p, s]) => { 
                const questionsAnswered = playerAnswerCounts[p];
                leaderboard += `<li>${p}: ${s} points (${questionsAnswered} questions answered)</li>`; 
            });
            leaderboard += '</ol>'; 
            scoreEl.innerHTML = leaderboard;
        } else {
            const totalPossible = questions.slice(0, currentQuestionIndex).reduce((a, b) => a + b.points, 0);
            const percentage = totalPossible > 0 ? Math.round((scores['Player'] / totalPossible) * 100) : 0;
            scoreEl.innerHTML = `
                <h2>🎉 Quiz Complete!</h2>
                <p>Your score: <strong>${scores['Player']} / ${totalPossible} points</strong></p>
                <p>Percentage: <strong>${percentage}%</strong></p>
                <p>Questions answered: <strong>${playerAnswerCounts['Player']}</strong></p>
            `;
        }
    }

    startBtn.addEventListener('click', () => { 
        startBtn.classList.add('hidden');
        // Reset counters
        currentQuestionIndex = 0;
        currentPlayerIndex = 0;
        currentPlayer = multiplayer ? multiplayer[0] : 'Player';
        showQuestion(); 
    });
    
    nextBtn.addEventListener('click', nextQuestion);
    
    endBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to end the quiz? This will show the final results.')) {
            showScore();
        }
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsPanel.style.display === 'flex') {
            toggleSettings();
        }
    });

})();
</script>
</body>
</html>